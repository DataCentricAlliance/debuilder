{"name":"Debuilder","tagline":"deb","body":"#Собрать пакет datacentric-debuild\r\n```bash\r\ngit clone https://github.com/DataCentricAlliance/debuilder.git\r\ncd debuilder/debuilder\r\nsudo apt-get install debhelper devscripts python-opster python-debian python-tz\r\n./deb.py build\r\n#пакет будет лежать в папке build\r\n```\r\n\r\n#Настройка окружения\r\n\r\n```bash\r\n#устанавливаем пакет datacentric-debuild\r\nsudo apt-get install datacentric-debuild\r\n\r\n#устанавливаем переменные окружения\r\nexport DEBEMAIL=\"i.ivanov@datacentric.ru\"\r\nexport DEBFULLNAME=\"Ivan Ivanov\"\r\nexport DEBREPOSITORY=\"example.repo.net:/opt/ubuntu/mini-dinstall/incoming/\"\r\n```\r\n\r\n#Увеличить версию пакета\r\n```bash\r\n#добавили запись в changelog и собрали с новой версией\r\n./deb.py build -v <maj|min|mntn|build> -m <message>\r\n\r\n#changelog надо закоммитить (лучше вместе с остальными изменениями пакета)\r\ngit commit -a -m \"теперь точно всё работает\"\r\n\r\n#мержим ветку через gitlab\r\ngit push origin ...\r\n\r\n#кладём пакет в репозиторий\r\n./deb.py pub\r\n```\r\n\r\n#Создание пакета\r\n\r\n```bash\r\n#создаём папку где будет лежать наш проект\r\nmkdir mypackage\r\ncd mkdir\r\n\r\n#создаём папку debian, changelog и файл deb.py\r\n#в папку debian нужно класть post/pre скрипты\r\nmkdir debian\r\ntouch debian/changelog\r\ntouch deb.py\r\nchmod a+x deb.py\r\n\r\n#добавляем всё в git\r\ngit add *\r\n\r\n#редактируем файл deb.py, смотреть \"Описание deb.py\"\r\nvim deb.py\r\n \r\n#добавляем запись в changelog и собираем пакет\r\n./deb.py build -v min -m \"Initial release\"\r\n\r\n#коммитим, проходим ревью, мёржим\r\ngit commit -a -m \"add new package mypackage\"\r\n\r\n#отправляем пакет в репозиторий\r\n./deb.py pub\r\n```\r\n\r\n#Описание deb.py\r\n\r\nПример:\r\n```python\r\n!/usr/bin/python\r\n\r\nfrom facetz.utils.debuild import *\r\n\r\ndispatch(\r\n    Package(\r\n        name = \"mypackage\",\r\n        section = \"facetz\",\r\n        description = \"Tool that is never falls\",\r\n        depends = \"python-pymongo\",\r\n        conflicts = \"myoldpackage\",\r\n\r\n        commands = [Copy([\"mypackage.*.cfg\"], \"/etc/mypackage/\"),\r\n                    EnvLink(\"/etc/mypackage/mypackage.$ENV.cfg\", \"/etc/mypackage/mypackage.cfg\"),\r\n                    Copy([\"tool.py\", \"common.py\"], \"/opt/facetz/mypackage/\")              \r\n                    Mkdir(\"/var/log/facetz/mypackage\")]\r\n    )\r\n)\r\n```\r\n\r\n* dispatch - нужен для разбора коммандной строки\r\n* Package - класс содержащий описание пакета:\r\n    * name - имя пакета\r\n    * section - секция пакета https://www.debian.org/doc/debian-policy/ch-archive.html#s-subsections\r\n    * description - описание пакета\r\n    * depends - зависимости от других deb-пакетов\r\n    * conflicts - конфликты с другими deb-пакетами\r\n    * provides - для виртуальных пакетов\r\n    * commands - команды сборщику пакета:\r\n        * Copy(wildcards, dest) - копирует файлы/папки в dest. Если dest заканчивается на '/' то копирует в папку dest. Если dest не заканчивается '/' то считается что при копировании вы хотите переименовать файл и он будет скопирован в папку dirname(dest) и назван basename(dest)\r\n        * Copy([\"myconf.cfg\"], \"/etc/facetz/tool/tool.cfg\") - файл myconf.cfg будет скопирован в папку /etc/facetz/tool и переименован в tool.cfg\r\n        * Copy([\"myconf.cfg\"], \"/etc/facetz/tool/\") - файл myconf.cfg будет скопирован в папку /etc/facetz/tool и не будет переименован\r\n        * Copy([\"conf\"], \"/etc/facetz/tool\") - если conf - это папка то она будет переименована в tool и скопирована в /etc/facetz\r\n        * Mkdir(dir_name, user=root, group=root) - создаст папку dir_name, добавляет chown user:group dir в postrm скрипт\r\n\r\n        * EnvLink(pattern, link_name=None) - Если у нас разные конфиги для каждого из окружений, к примеру tool.development.cfg, tool.testing.cfg, tool.production.cfg, чтобы не создавать три пакета с каждым из этих конфигов, можно использовать EnvLink. Для этого нужно положить все конфиги в один пакет командой Copy а затем создать ссылку на конфиг с помощью EnvLink.\r\n        ```python\r\n        #Для нашего примера\r\n        Copy([\"tool.*.cfg\"], \"/etc/facetz/tool/\")\r\n        EnvLink(\"/etc/facetz/tool/tool.$ENV.cfg\", \"/etc/facetz/tool/tool.cfg\")\r\n        ```\r\n        EnvLink создаст символьную ссылку /etc/facetz/tool/tool.cfg -> /etc/facetz/tool/tool.development.cfg если на машине установлен пакет facetz-env-development или /etc/facetz/tool/tool.cfg -> /etc/facetz/tool/tool.production.cfg если на машине стоит пакет facetz-env-production. Таки образом мы можем в нашей программе использовать один путь для всех конфигов \"/etc/facetz/too/tool.cfg\", а какой именно конфиг будет подключем определяется созданной в момент установки пакета ссылкой.\r\n        Как это работает? Есть пакеты окружения facez-env-development, facetz-env-testing, facetz-env-production и виртуальный пакет facetz-env. Каждый из них устанавливает на машину файл /etc/facetz/env/env.cfg который содержит одну строчку \"development\", \"testing\" или \"production\". На машине может стоять только один из них. Команда EnvLink добавляет в postinst скрипт две строки:\r\n        ```bash\r\n        ENV=$(cat /etc/facetz/env/env.cfg)\r\n        ln -sf <pattern> <link_name>\r\n        ```\r\n        и в postrm скрипт:\r\n        ```bash\r\n        extra_portrm\r\n        rm -rf <link_name>\r\n        ```\r\n    \r\n    \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}